/**
* SidescrollSection Class creates an object for all '[data-sidescroll]' elements and does some sidescroll magic with them when it's
* at the top of the page on scroll
*/
class SidescrollSection {
  constructor(el, indx) {
    this.el = el;
    this.index = indx;
    this.animation;
    this.sectionHeight;
    // find the required children inside this section (they'll also be generated by the init() method)
    this.inner = this.el.querySelector('.inner') || false;
    this.hScroller = this.el.querySelector('.h-scroller') || false;
    this.hInner = this.el.querySelector('.h-inner') || false;
    this.hContent = this.el.querySelector('.h-content') || false;
  }
  /* When init() is called it will generate the required elements for sidescroll to work (but only if they aren't there already) */
  init() {
    this.el.classList.add('sidescroll'); // add a .sidescroll class to the container just in case
    this.el.dataset.index = this.index; // add an index to the sidescroll element

    if(!this.inner && !this.hScroller) {
      // create .inner div
      this.inner = document.createElement('div');
      this.inner.classList.add('inner');
      // create and append .h-scroller div
      this.hScroller = document.createElement('div');
      this.hScroller.classList.add('h-scroller');
      this.inner.append(this.hScroller);
      // create and append .h-inner div
      this.hInner = document.createElement('div');
      this.hInner.classList.add('h-inner');
      this.hScroller.append(this.hInner);
      // create and append .h-content div
      this.hContent = document.createElement('div');
      this.hContent.classList.add('h-content');
      this.hContent.innerHTML = this.el.innerHTML;
      this.hInner.append(this.hContent);
      // append .inner div
      this.el.innerHTML = '';
      this.el.append(this.inner);
    }
  }
  /* Calculate the required height of the outer container (based on what's inside the total width inside the inner container */
  setDynamicHeight() {
    let bounds = this.hContent.getBoundingClientRect();
    this.sectionHeight = Math.round(bounds.width - vw + vh); // vw and vh should be declared and updated in core.js
    this.el.style.height = this.sectionHeight + "px";
    this.el.dataset.screens = Math.abs(Math.round(((bounds.width - vw) / vw) * 100) / 100);

    let target = this.hScroller;
    this.animation = anime({
      targets: target,
      translateX: [0, -this.sectionHeight],
      autoplay: false,
      easing: 'linear',
    });
  }
  sidescroll() {
    // negative offsetTop of inner element (the one that's sticky)
    let offsetTop = this.inner.offsetTop;

    // option 1: set the translateX when inner element gets sticky on top
    //this.hScroller.style.transform = "translateX(" + -offsetTop + "px)";

    // option 2: via anime.seek animation (declared in the setDynamicHeight() method)
    // this option seems to be the least processor intensive
    if(this.animation) {
      this.animation.seek(this.animation.duration * offsetTop / this.sectionHeight);
    }

    // option 3: via anime.set
    /*let obj = this;
    debounce(function () {
    anime.set(obj.hScroller, {
    translateX: -offsetTop,
  });
});*/

// update the current screen widths passed
this.el.dataset.screenWidth = Math.round((offsetTop / vw) * 100) / 100;
}
get element() {
  return this.el;
}
}



/*
* Global vars
*/
var sidescrollEls = document.querySelectorAll('[data-sidescroll]'), sidescrollSections = [], sidescrollIndx = 0;




/*
* Correct the dynamicheight of the sidescroll sections on window resize
*/
var vwSidescroll = vw; // the 'vw' var is defined in core.js
var windowResizeSidescroll = debounce(function() {
  // sometimes mobile safari fires a resize event when it's not expected so first check if the new window width had truly changed
  if(vwSidescroll != window.innerWidth) {
    // check if there are any [data-sidescroll] sections on screen that need to be resized
    sidescrollSections.forEach((section, i) => {
      section.setDynamicHeight();
      if( getInView(section.element) ) {
        section.sidescroll();
      }
    });

    // update current vw
    vwSidescroll = window.innerWidth;
  }
});
window.addEventListener('resize', windowResizeSidescroll);



/*
* Make the horizontal scroll react on scroll
*/
var windowScrollSidescroll = debounce(function() {
  // check if there are any [data-sidescroll] sections on screen that need to be resized
  sidescrollSections.forEach((section, i) => {
    if( getInView(section.element) ) {
      section.sidescroll();
    }
  });
});
window.addEventListener('scroll', windowScrollSidescroll);



/*
* On page load, trigger the sidescrolls and add them into a global array
*/
window.addEventListener('load', () => {
  // create a SidescrollSection class for all the [data-sidescroll] elements and push them into a global array called sidescrollSections
  sidescrollEls.forEach((el, i) => {
    var section = new SidescrollSection(el, sidescrollIndx);
    // Push this new section in the global array of sidescrollSections objects
    sidescrollSections.push(section);
    // on pageload init the objects
    section.init();
    // on pageload set the height
    section.setDynamicHeight();

    sidescrollIndx++;
  });

  // trigger the sidescrolls
  windowScrollSidescroll();
}, false);





/*
* This is a fix for sidescroll.js and lazysizes.js
* When we use sidescroll with lazyloaded images inside the sidescroll, we face a problem:
* The sidescroll wrapper won't be wide enough as it won't have accounted for the height and width of each lazyloaded image
* This lazysizes callback fixes that problem by recalculating the width of the wrapper after each lazyload
*
* Naturally, this extension is useless if lazysizes.js isn't already loaded
*/
document.addEventListener('lazybeforeunveil', function(event) {
  // also only resize if the image has a sidescroll-img class
  if ( !event.target.classList.contains('sidescroll-img') ) return;

  // check if this lazyloaded image is a child of a sidescroll element
  let parentEl = event.target.closest('[data-sidescroll]');

  // recalculate the dynamic height of the wrapper (sidescrollSections is a global)
  if(parentEl) {
    setTimeout(function() {
      sidescrollSections[parentEl.dataset.index].setDynamicHeight();
    }, 66);
  }
});
